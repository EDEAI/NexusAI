START TRANSACTION;

INSERT INTO `apps` (`team_id`, `user_id`, `name`, `description`, `avatar`, `icon`, `icon_background`, `mode`, `enable_api`, `api_token`, `is_public`, `publish_status`, `attrs_are_visible`) VALUES (1, 1, 'Task JSON to PPT', '', NULL, '1', '', 4, 0, NULL, 1, 1, 1);
SET @new_id = LAST_INSERT_ID();
INSERT INTO `custom_tools` (`team_id`, `user_id`, `app_id`, `config`, `input_variables`, `dependencies`, `code`, `output_type`, `output_variables`, `publish_status`, `published_time`) VALUES (1, 1, @new_id, NULL, '{"name": "input_var", "type": "object", "properties": {"task_data": {"name": "task_data", "type": "json", "value": "", "required": true, "sort_order": 1, "display_name": "Task Data"}}, "sort_order": 0, "display_name": "Input Object Variable"}', '{"python3": ["python-pptx"]}', '{"python3":"from pptx import Presentation\\nfrom pptx.util import Pt, Cm\\nfrom pptx.enum.text import PP_ALIGN\\nimport os\\nimport uuid\\nfrom typing import Dict, Any, List, Tuple\\n\\ndef main(task_data: Dict[str, Any]) -> dict:\\n    \\"\\"\\"\\n    优化PPT美观性：\\n    1. 所有内容左对齐，不分页。\\n    2. 段落之间增加适当间距（如段后8pt）。\\n    3. 标题（name）加粗、字号18，内容16。\\n    4. 代码块用浅灰色背景、等宽字体。\\n    5. 保留空行。\\n    6. 内容区上下左右留白适当（如内容区左右各缩进1.1cm）。\\n    7. 适当增加行距（如1.1倍）。\\n    8. 换行后所有行与首行左对齐，无多余缩进或空隙。\\n    9. 段落首行加两个全角空格（\\\\u3000\\\\u3000），后续自动换行的行与左边界对齐。\\n    \\"\\"\\"\\n    file_name = f\\"{uuid.uuid4()}.pptx\\"\\n    file_path = f\\"/storage/{file_name}\\"\\n    directory = os.path.dirname(file_path)\\n    if directory and not os.path.exists(directory):\\n        os.makedirs(directory, exist_ok=True)\\n\\n    prs = Presentation()\\n    default_font_name = \\"宋体\\"\\n    code_font_name = \\"Courier New\\"\\n    normal_font_size = Pt(16)\\n    title_font_size = Pt(32)\\n    main_title_font_size = Pt(30)\\n    name_font_size = Pt(18)\\n    para_space_after = Pt(8)\\n    line_spacing = 1.1  # 更紧凑的行距\\n    content_margin = Cm(2)\\n    code_bg_color = \\"#F2F2F2\\"\\n    indent_str = \'\\\\u3000\\\\u3000\'  # 两个全角空格\\n\\n    def add_title_slide(title: str):\\n        slide = prs.slides.add_slide(prs.slide_layouts[0])\\n        slide.shapes.title.text = title\\n        for run in slide.shapes.title.text_frame.paragraphs[0].runs:\\n            run.font.name = \\"黑体\\"\\n            run.font.size = main_title_font_size\\n            run.font.bold = True\\n\\n    def add_content_slide(title: str):\\n        slide = prs.slides.add_slide(prs.slide_layouts[1])\\n        slide.shapes.title.text = title\\n        for run in slide.shapes.title.text_frame.paragraphs[0].runs:\\n            run.font.name = \\"黑体\\"\\n            run.font.size = title_font_size\\n            run.font.bold = True\\n        tf = slide.shapes.placeholders[1].text_frame\\n        tf.clear()\\n        # 设置内容区左右留白\\n        left = content_margin\\n        top = content_margin\\n        width = prs.slide_width - 2 * content_margin\\n        height = prs.slide_height - 2 * content_margin\\n        # 重新定位内容框\\n        content_shape = slide.shapes.placeholders[1]\\n        content_shape.left = left\\n        content_shape.top = top\\n        content_shape.width = width\\n        content_shape.height = height\\n        # 关键：去除文本框内边距，保证换行后所有行与首行左对齐\\n        tf.margin_left = 0\\n        tf.margin_right = 0\\n        tf.margin_top = 0\\n        tf.margin_bottom = 0\\n        return tf\\n\\n    def add_bullet(tf, text: str, indent: int = 0, bold: bool = False, is_code: bool = False, level: int = 1):\\n        para_level = 0\\n        # 只要正文或代码块，且level>=2（第二层级及以上），首行加全角空格，标题不加\\n        need_indent = (not bold) and (level >= 2)\\n        indent_str = \'\\\\u3000\\\\u3000\' if need_indent else \'\'\\n        # 空行\\n        if text == \\"\\":\\n            p = tf.add_paragraph()\\n            p.text = \\"\\"\\n            p.level = para_level\\n            p.alignment = PP_ALIGN.LEFT\\n            p.space_after = para_space_after\\n            p.line_spacing = line_spacing\\n            for run in p.runs:\\n                run.font.name = default_font_name\\n                run.font.size = normal_font_size\\n            return\\n        # 代码块\\n        if is_code:\\n            p = tf.add_paragraph()\\n            p.text = indent_str + text\\n            p.level = para_level\\n            p.alignment = PP_ALIGN.LEFT\\n            p.space_after = para_space_after\\n            p.line_spacing = line_spacing\\n            for run in p.runs:\\n                run.font.name = code_font_name\\n                run.font.size = normal_font_size\\n                run.font.bold = False\\n            # 设置浅灰色背景\\n            try:\\n                from pptx.oxml.xmlchemy import OxmlElement\\n                pPr = p._element.get_or_add_pPr()\\n                solidFill = OxmlElement(\'a:solidFill\')\\n                srgbClr = OxmlElement(\'a:srgbClr\')\\n                srgbClr.set(\'val\', code_bg_color.replace(\'#\', \'\'))\\n                solidFill.append(srgbClr)\\n                pPr.append(solidFill)\\n            except Exception:\\n                pass\\n            return\\n        # 标题name\\n        if bold:\\n            p = tf.add_paragraph()\\n            p.text = text\\n            p.level = para_level\\n            p.alignment = PP_ALIGN.LEFT\\n            p.space_after = para_space_after\\n            p.line_spacing = line_spacing\\n            for run in p.runs:\\n                run.font.name = default_font_name\\n                run.font.size = name_font_size\\n                run.font.bold = True\\n            return\\n        # 普通内容\\n        lines = text.split(\'\\\\n\')\\n        for idx, line in enumerate(lines):\\n            p = tf.add_paragraph()\\n            p.text = indent_str + (line if line != \\"\\" else \\"\\")\\n            p.level = para_level\\n            p.alignment = PP_ALIGN.LEFT\\n            p.space_after = para_space_after\\n            p.line_spacing = line_spacing\\n            for run in p.runs:\\n                run.font.name = default_font_name\\n                run.font.size = normal_font_size\\n                run.font.bold = False\\n            # 去除项目符号\\n            try:\\n                p.bullet = False\\n            except Exception:\\n                pass\\n            pPr = p._element.get_or_add_pPr()\\n            for bu in pPr.findall(\'.//a:buChar\', namespaces={\'a\': \'http://schemas.openxmlformats.org/drawingml/2006/main\'}):\\n                pPr.remove(bu)\\n            for bu in pPr.findall(\'.//a:buFont\', namespaces={\'a\': \'http://schemas.openxmlformats.org/drawingml/2006/main\'}):\\n                pPr.remove(bu)\\n            for bu in pPr.findall(\'.//a:buNone\', namespaces={\'a\': \'http://schemas.openxmlformats.org/drawingml/2006/main\'}):\\n                pPr.remove(bu)\\n            from pptx.oxml.xmlchemy import OxmlElement\\n            buNone = OxmlElement(\'a:buNone\')\\n            pPr.append(buNone)\\n\\n    def process_task_content(task_content, indent=0, level=1):\\n        lines = task_content.split(\'\\\\n\')\\n        result = []\\n        i = 0\\n        while i < len(lines):\\n            line = lines[i]\\n            if line.startswith(\'```\'):\\n                code_lines = [line]\\n                i += 1\\n                while i < len(lines) and not lines[i].startswith(\'```\'):\\n                    code_lines.append(lines[i])\\n                    i += 1\\n                if i < len(lines):\\n                    code_lines.append(lines[i])\\n                code_text = \'\\\\n\'.join(code_lines)\\n                result.append((code_text, False, True, indent, level))\\n                i += 1\\n                continue\\n            result.append((line, False, False, indent, level))\\n            i += 1\\n        return result\\n\\n    def process_category(category, level=1):\\n        indent = 0 if level == 1 else 1\\n        if level == 1:\\n            add_title_slide(category.get(\'name\', \'\'))\\n        elif level == 2:\\n            if category.get(\'subcategories\'):\\n                content = []\\n                if category.get(\'name\'):\\n                    content.append((category[\'name\'], True, False, indent, level))\\n                if category.get(\'description\'):\\n                    content.append((category[\'description\'], False, False, indent, level))\\n                tf = add_content_slide(category.get(\'name\', \'\'))\\n                for para, is_bold, is_code, ind, lvl in content:\\n                    add_bullet(tf, para, indent=ind, bold=is_bold, is_code=is_code, level=lvl)\\n            else:\\n                content = []\\n                if category.get(\'name\'):\\n                    content.append((category[\'name\'], True, False, indent, level))\\n                if category.get(\'description\'):\\n                    content.append((category[\'description\'], False, False, indent, level))\\n                if category.get(\'task\'):\\n                    content.extend(process_task_content(category[\'task\'], indent=indent, level=level))\\n                tf = add_content_slide(category.get(\'name\', \'\'))\\n                for para, is_bold, is_code, ind, lvl in content:\\n                    add_bullet(tf, para, indent=ind, bold=is_bold, is_code=is_code, level=lvl)\\n        else:\\n            if category.get(\'subcategories\'):\\n                content = []\\n                if category.get(\'name\'):\\n                    content.append((category[\'name\'], True, False, indent, level))\\n                if category.get(\'description\'):\\n                    content.append((category[\'description\'], False, False, indent, level))\\n                tf = add_content_slide(category.get(\'name\', \'\'))\\n                for para, is_bold, is_code, ind, lvl in content:\\n                    add_bullet(tf, para, indent=ind, bold=is_bold, is_code=is_code, level=lvl)\\n            else:\\n                content = []\\n                if category.get(\'name\'):\\n                    content.append((category[\'name\'], True, False, indent, level))\\n                if category.get(\'description\'):\\n                    content.append((category[\'description\'], False, False, indent, level))\\n                if category.get(\'task\'):\\n                    content.extend(process_task_content(category[\'task\'], indent=indent, level=level))\\n                tf = add_content_slide(category.get(\'name\', \'\'))\\n                for para, is_bold, is_code, ind, lvl in content:\\n                    add_bullet(tf, para, indent=ind, bold=is_bold, is_code=is_code, level=lvl)\\n        if category.get(\'subcategories\'):\\n            for sub in category[\'subcategories\']:\\n                process_category(sub, level+1)\\n\\n    # 顶层只显示name\\n    if \'name\' in task_data:\\n        add_title_slide(task_data[\'name\'])\\n    # 递归处理所有子类\\n    if \'subcategories\' in task_data:\\n        for cat in task_data[\'subcategories\']:\\n            process_category(cat, level=2)\\n\\n    try:\\n        prs.save(file_path)\\n        return {\\n            \\"success\\": \\"True\\",\\n            \\"file_path\\": f\\"file://{file_path}\\"\\n        }\\n    except Exception as e:\\n        return {\\n            \\"success\\": \\"False\\",\\n            \\"file_path\\": \\"\\"\\n        }"}', 4, '{"name": "input_var", "type": "object", "properties": {"success": {"name": "success", "type": "string", "value": "", "required": true, "max_length": 0, "sort_order": 1, "display_name": "SUCCESS"}, "file_path": {"name": "file_path", "type": "file", "value": "", "required": true, "sort_order": 2, "display_name": "File Path"}}, "sort_order": 0, "display_name": "Input Object Variable"}', 0, NULL);
INSERT INTO `custom_tools` (`team_id`, `user_id`, `app_id`, `config`, `input_variables`, `dependencies`, `code`, `output_type`, `output_variables`, `publish_status`, `published_time`) VALUES (1, 1, @new_id, NULL, '{"name": "input_var", "type": "object", "properties": {"task_data": {"name": "task_data", "type": "json", "value": "", "required": true, "sort_order": 1, "display_name": "Task Data"}}, "sort_order": 0, "display_name": "Input Object Variable"}', '{"python3": ["python-pptx"]}', '{"python3":"from pptx import Presentation\\nfrom pptx.util import Pt, Cm\\nfrom pptx.enum.text import PP_ALIGN\\nimport os\\nimport uuid\\nfrom typing import Dict, Any, List, Tuple\\n\\ndef main(task_data: Dict[str, Any]) -> dict:\\n    \\"\\"\\"\\n    优化PPT美观性：\\n    1. 所有内容左对齐，不分页。\\n    2. 段落之间增加适当间距（如段后8pt）。\\n    3. 标题（name）加粗、字号18，内容16。\\n    4. 代码块用浅灰色背景、等宽字体。\\n    5. 保留空行。\\n    6. 内容区上下左右留白适当（如内容区左右各缩进1.1cm）。\\n    7. 适当增加行距（如1.1倍）。\\n    8. 换行后所有行与首行左对齐，无多余缩进或空隙。\\n    9. 段落首行加两个全角空格（\\\\u3000\\\\u3000），后续自动换行的行与左边界对齐。\\n    \\"\\"\\"\\n    file_name = f\\"{uuid.uuid4()}.pptx\\"\\n    file_path = f\\"/storage/{file_name}\\"\\n    directory = os.path.dirname(file_path)\\n    if directory and not os.path.exists(directory):\\n        os.makedirs(directory, exist_ok=True)\\n\\n    prs = Presentation()\\n    default_font_name = \\"宋体\\"\\n    code_font_name = \\"Courier New\\"\\n    normal_font_size = Pt(16)\\n    title_font_size = Pt(32)\\n    main_title_font_size = Pt(30)\\n    name_font_size = Pt(18)\\n    para_space_after = Pt(8)\\n    line_spacing = 1.1  # 更紧凑的行距\\n    content_margin = Cm(2)\\n    code_bg_color = \\"#F2F2F2\\"\\n    indent_str = \'\\\\u3000\\\\u3000\'  # 两个全角空格\\n\\n    def add_title_slide(title: str):\\n        slide = prs.slides.add_slide(prs.slide_layouts[0])\\n        slide.shapes.title.text = title\\n        for run in slide.shapes.title.text_frame.paragraphs[0].runs:\\n            run.font.name = \\"黑体\\"\\n            run.font.size = main_title_font_size\\n            run.font.bold = True\\n\\n    def add_content_slide(title: str):\\n        slide = prs.slides.add_slide(prs.slide_layouts[1])\\n        slide.shapes.title.text = title\\n        for run in slide.shapes.title.text_frame.paragraphs[0].runs:\\n            run.font.name = \\"黑体\\"\\n            run.font.size = title_font_size\\n            run.font.bold = True\\n        tf = slide.shapes.placeholders[1].text_frame\\n        tf.clear()\\n        # 设置内容区左右留白\\n        left = content_margin\\n        top = content_margin\\n        width = prs.slide_width - 2 * content_margin\\n        height = prs.slide_height - 2 * content_margin\\n        # 重新定位内容框\\n        content_shape = slide.shapes.placeholders[1]\\n        content_shape.left = left\\n        content_shape.top = top\\n        content_shape.width = width\\n        content_shape.height = height\\n        # 关键：去除文本框内边距，保证换行后所有行与首行左对齐\\n        tf.margin_left = 0\\n        tf.margin_right = 0\\n        tf.margin_top = 0\\n        tf.margin_bottom = 0\\n        return tf\\n\\n    def add_bullet(tf, text: str, indent: int = 0, bold: bool = False, is_code: bool = False, level: int = 1):\\n        para_level = 0\\n        # 只要正文或代码块，且level>=2（第二层级及以上），首行加全角空格，标题不加\\n        need_indent = (not bold) and (level >= 2)\\n        indent_str = \'\\\\u3000\\\\u3000\' if need_indent else \'\'\\n        # 空行\\n        if text == \\"\\":\\n            p = tf.add_paragraph()\\n            p.text = \\"\\"\\n            p.level = para_level\\n            p.alignment = PP_ALIGN.LEFT\\n            p.space_after = para_space_after\\n            p.line_spacing = line_spacing\\n            for run in p.runs:\\n                run.font.name = default_font_name\\n                run.font.size = normal_font_size\\n            return\\n        # 代码块\\n        if is_code:\\n            p = tf.add_paragraph()\\n            p.text = indent_str + text\\n            p.level = para_level\\n            p.alignment = PP_ALIGN.LEFT\\n            p.space_after = para_space_after\\n            p.line_spacing = line_spacing\\n            for run in p.runs:\\n                run.font.name = code_font_name\\n                run.font.size = normal_font_size\\n                run.font.bold = False\\n            # 设置浅灰色背景\\n            try:\\n                from pptx.oxml.xmlchemy import OxmlElement\\n                pPr = p._element.get_or_add_pPr()\\n                solidFill = OxmlElement(\'a:solidFill\')\\n                srgbClr = OxmlElement(\'a:srgbClr\')\\n                srgbClr.set(\'val\', code_bg_color.replace(\'#\', \'\'))\\n                solidFill.append(srgbClr)\\n                pPr.append(solidFill)\\n            except Exception:\\n                pass\\n            return\\n        # 标题name\\n        if bold:\\n            p = tf.add_paragraph()\\n            p.text = text\\n            p.level = para_level\\n            p.alignment = PP_ALIGN.LEFT\\n            p.space_after = para_space_after\\n            p.line_spacing = line_spacing\\n            for run in p.runs:\\n                run.font.name = default_font_name\\n                run.font.size = name_font_size\\n                run.font.bold = True\\n            return\\n        # 普通内容\\n        lines = text.split(\'\\\\n\')\\n        for idx, line in enumerate(lines):\\n            p = tf.add_paragraph()\\n            p.text = indent_str + (line if line != \\"\\" else \\"\\")\\n            p.level = para_level\\n            p.alignment = PP_ALIGN.LEFT\\n            p.space_after = para_space_after\\n            p.line_spacing = line_spacing\\n            for run in p.runs:\\n                run.font.name = default_font_name\\n                run.font.size = normal_font_size\\n                run.font.bold = False\\n            # 去除项目符号\\n            try:\\n                p.bullet = False\\n            except Exception:\\n                pass\\n            pPr = p._element.get_or_add_pPr()\\n            for bu in pPr.findall(\'.//a:buChar\', namespaces={\'a\': \'http://schemas.openxmlformats.org/drawingml/2006/main\'}):\\n                pPr.remove(bu)\\n            for bu in pPr.findall(\'.//a:buFont\', namespaces={\'a\': \'http://schemas.openxmlformats.org/drawingml/2006/main\'}):\\n                pPr.remove(bu)\\n            for bu in pPr.findall(\'.//a:buNone\', namespaces={\'a\': \'http://schemas.openxmlformats.org/drawingml/2006/main\'}):\\n                pPr.remove(bu)\\n            from pptx.oxml.xmlchemy import OxmlElement\\n            buNone = OxmlElement(\'a:buNone\')\\n            pPr.append(buNone)\\n\\n    def process_task_content(task_content, indent=0, level=1):\\n        lines = task_content.split(\'\\\\n\')\\n        result = []\\n        i = 0\\n        while i < len(lines):\\n            line = lines[i]\\n            if line.startswith(\'```\'):\\n                code_lines = [line]\\n                i += 1\\n                while i < len(lines) and not lines[i].startswith(\'```\'):\\n                    code_lines.append(lines[i])\\n                    i += 1\\n                if i < len(lines):\\n                    code_lines.append(lines[i])\\n                code_text = \'\\\\n\'.join(code_lines)\\n                result.append((code_text, False, True, indent, level))\\n                i += 1\\n                continue\\n            result.append((line, False, False, indent, level))\\n            i += 1\\n        return result\\n\\n    def process_category(category, level=1):\\n        indent = 0 if level == 1 else 1\\n        if level == 1:\\n            add_title_slide(category.get(\'name\', \'\'))\\n        elif level == 2:\\n            if category.get(\'subcategories\'):\\n                content = []\\n                if category.get(\'name\'):\\n                    content.append((category[\'name\'], True, False, indent, level))\\n                if category.get(\'description\'):\\n                    content.append((category[\'description\'], False, False, indent, level))\\n                tf = add_content_slide(category.get(\'name\', \'\'))\\n                for para, is_bold, is_code, ind, lvl in content:\\n                    add_bullet(tf, para, indent=ind, bold=is_bold, is_code=is_code, level=lvl)\\n            else:\\n                content = []\\n                if category.get(\'name\'):\\n                    content.append((category[\'name\'], True, False, indent, level))\\n                if category.get(\'description\'):\\n                    content.append((category[\'description\'], False, False, indent, level))\\n                if category.get(\'task\'):\\n                    content.extend(process_task_content(category[\'task\'], indent=indent, level=level))\\n                tf = add_content_slide(category.get(\'name\', \'\'))\\n                for para, is_bold, is_code, ind, lvl in content:\\n                    add_bullet(tf, para, indent=ind, bold=is_bold, is_code=is_code, level=lvl)\\n        else:\\n            if category.get(\'subcategories\'):\\n                content = []\\n                if category.get(\'name\'):\\n                    content.append((category[\'name\'], True, False, indent, level))\\n                if category.get(\'description\'):\\n                    content.append((category[\'description\'], False, False, indent, level))\\n                tf = add_content_slide(category.get(\'name\', \'\'))\\n                for para, is_bold, is_code, ind, lvl in content:\\n                    add_bullet(tf, para, indent=ind, bold=is_bold, is_code=is_code, level=lvl)\\n            else:\\n                content = []\\n                if category.get(\'name\'):\\n                    content.append((category[\'name\'], True, False, indent, level))\\n                if category.get(\'description\'):\\n                    content.append((category[\'description\'], False, False, indent, level))\\n                if category.get(\'task\'):\\n                    content.extend(process_task_content(category[\'task\'], indent=indent, level=level))\\n                tf = add_content_slide(category.get(\'name\', \'\'))\\n                for para, is_bold, is_code, ind, lvl in content:\\n                    add_bullet(tf, para, indent=ind, bold=is_bold, is_code=is_code, level=lvl)\\n        if category.get(\'subcategories\'):\\n            for sub in category[\'subcategories\']:\\n                process_category(sub, level+1)\\n\\n    # 顶层只显示name\\n    if \'name\' in task_data:\\n        add_title_slide(task_data[\'name\'])\\n    # 递归处理所有子类\\n    if \'subcategories\' in task_data:\\n        for cat in task_data[\'subcategories\']:\\n            process_category(cat, level=2)\\n\\n    try:\\n        prs.save(file_path)\\n        return {\\n            \\"success\\": \\"True\\",\\n            \\"file_path\\": f\\"file://{file_path}\\"\\n        }\\n    except Exception as e:\\n        return {\\n            \\"success\\": \\"False\\",\\n            \\"file_path\\": \\"\\"\\n        }"}', 4, '{"name": "input_var", "type": "object", "properties": {"success": {"name": "success", "type": "string", "value": "", "required": true, "max_length": 0, "sort_order": 1, "display_name": "SUCCESS"}, "file_path": {"name": "file_path", "type": "file", "value": "", "required": true, "sort_order": 2, "display_name": "File Path"}}, "sort_order": 0, "display_name": "Input Object Variable"}', 1, CURRENT_TIMESTAMP());

INSERT INTO `apps` (`team_id`, `user_id`, `name`, `description`, `avatar`, `icon`, `icon_background`, `mode`, `enable_api`, `api_token`, `is_public`, `publish_status`, `attrs_are_visible`) VALUES (1, 1, 'Task JSON to Word', '', NULL, '1', '', 4, 0, NULL, 1, 1, 1);
SET @new_id = LAST_INSERT_ID();
INSERT INTO `custom_tools` (`team_id`, `user_id`, `app_id`, `config`, `input_variables`, `dependencies`, `code`, `output_type`, `output_variables`, `publish_status`, `published_time`) VALUES (1, 1, @new_id, NULL, '{"name": "input_var", "type": "object", "properties": {"task_data": {"name": "task_data", "type": "json", "value": "", "required": true, "sort_order": 1, "display_name": "Task Data"}}, "sort_order": 0, "display_name": "Input Object Variable"}', '{"python3": ["python-docx"]}', '{"python3":"from docx import Document\\nfrom docx.shared import Pt\\nfrom docx.enum.text import WD_ALIGN_PARAGRAPH\\nfrom docx.enum.style import WD_STYLE_TYPE\\nfrom docx.oxml.ns import qn\\nfrom typing import Dict, Any\\nimport os\\nimport uuid\\n\\ndef main(task_data: Dict[str, Any]) -> dict:\\n    \\"\\"\\"\\n    Convert JSON data to Word document, with different levels corresponding to different sections\\n    \\n    Args:\\n        task_data: Can be JSON string or Python dictionary\\n        \\n    Returns:\\n        dict: Dictionary containing operation result and file path\\n    \\"\\"\\"\\n\\n    # Generate a unique filename using UUID\\n    file_name = f\\"{uuid.uuid4()}.docx\\"\\n    file_path = f\\"/storage/{file_name}\\"\\n    \\n    # Ensure directory exists\\n    directory = os.path.dirname(file_path)\\n    if not os.path.exists(directory):\\n        os.makedirs(directory, exist_ok=True)\\n    \\n    # Create new Word document\\n    doc = Document()\\n    \\n    # Set Chinese font\\n    doc.styles[\'Normal\'].font.name = \'宋体\'\\n    doc.styles[\'Normal\']._element.rPr.rFonts.set(qn(\'w:eastAsia\'), \'宋体\')\\n    \\n    # Add document title style\\n    title_style = doc.styles.add_style(\'CustomTitle\', WD_STYLE_TYPE.PARAGRAPH)\\n    title_style.font.name = \'黑体\'\\n    title_style.font.size = Pt(18)\\n    title_style.font.bold = True\\n    title_style.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER\\n    title_style.paragraph_format.space_before = Pt(24)\\n    title_style.paragraph_format.space_after = Pt(18)\\n    # Set Chinese font\\n    title_style._element.rPr.rFonts.set(qn(\'w:eastAsia\'), \'黑体\')\\n    \\n    # Add level counters\\n    level_counters = {}\\n    \\n    # Chinese numbers configuration (unified)\\n    CHINESE_NUMBERS = [\\n        \'一\', \'二\', \'三\', \'四\', \'五\', \'六\', \'七\', \'八\', \'九\', \'十\',\\n        \'十一\', \'十二\', \'十三\', \'十四\', \'十五\', \'十六\', \'十七\', \'十八\', \'十九\', \'二十\',\\n        \'二十一\', \'二十二\', \'二十三\', \'二十四\', \'二十五\', \'二十六\', \'二十七\', \'二十八\', \'二十九\', \'三十\',\\n        \'三十一\', \'三十二\', \'三十三\', \'三十四\', \'三十五\', \'三十六\', \'三十七\', \'三十八\', \'三十九\', \'四十\',\\n        \'四十一\', \'四十二\', \'四十三\', \'四十四\', \'四十五\', \'四十六\', \'四十七\', \'四十八\', \'四十九\', \'五十\'\\n    ]\\n    \\n    # Generate Chinese number prefixes for pattern matching\\n    CHINESE_NUMBER_PREFIXES = tuple(num + \'、\' for num in CHINESE_NUMBERS)\\n    \\n    def reset_counters_from_level(level):\\n        \\"\\"\\"Reset counters from specified level and below\\"\\"\\"\\n        keys_to_remove = [k for k in level_counters.keys() if k >= level]\\n        for key in keys_to_remove:\\n            del level_counters[key]\\n    \\n    def get_level_number(level):\\n        \\"\\"\\"Get level number for specified level\\"\\"\\"\\n        # Reset deeper level counters\\n        reset_counters_from_level(level + 1)\\n        \\n        # Increment current level counter\\n        if level not in level_counters:\\n            level_counters[level] = 0\\n        level_counters[level] += 1\\n        \\n        if level == 1:\\n            # First level uses Chinese numbers\\n            if level_counters[level] <= len(CHINESE_NUMBERS):\\n                return CHINESE_NUMBERS[level_counters[level] - 1] + \'、\'\\n            else:\\n                return f\\"{level_counters[level]}、\\"\\n        elif level == 2:\\n            # Second level uses \\"1.1, 1.2\\" format, corresponding to first level number\\n            first_level_num = level_counters.get(1, 1)  # Get first level number\\n            return f\\"{first_level_num}.{level_counters[level]}、\\"\\n        else:\\n            # Third level and beyond use multi-level numbers\\n            if level == 3:\\n                first_level_num = level_counters.get(1, 1)\\n                return f\\"{first_level_num}.{level_counters[2]}.{level_counters[level]} \\"\\n            elif level == 4:\\n                first_level_num = level_counters.get(1, 1)\\n                return f\\"{first_level_num}.{level_counters[2]}.{level_counters[3]}.{level_counters[level]} \\"\\n            elif level == 5:\\n                first_level_num = level_counters.get(1, 1)\\n                return f\\"{first_level_num}.{level_counters[2]}.{level_counters[3]}.{level_counters[4]}.{level_counters[level]} \\"\\n            else:\\n                # Deeper levels continue expansion\\n                first_level_num = level_counters.get(1, 1)\\n                parts = [str(first_level_num)]\\n                for i in range(2, level + 1):\\n                    if i in level_counters:\\n                        parts.append(str(level_counters[i]))\\n                return \'.\'.join(parts) + \' \'\\n\\n    # Internal function: add heading with level numbering\\n    def add_heading(text, level=1):\\n        # Get level number\\n        level_number = get_level_number(level)\\n        numbered_text = level_number + text\\n        \\n        # Define style configuration for each level\\n        level_configs = {\\n            1: {\'font_size\': 16, \'space_before\': 18, \'space_after\': 12},\\n            2: {\'font_size\': 14, \'space_before\': 12, \'space_after\': 8},\\n            3: {\'font_size\': 13, \'space_before\': 10, \'space_after\': 6},\\n            # Default configuration for level 4 and below\\n            \'default\': {\'font_size\': 12, \'space_before\': 8, \'space_after\': 4}\\n        }\\n        \\n        def apply_heading_style(heading, font_size, space_before, space_after):\\n            \\"\\"\\"Common function to apply heading styles\\"\\"\\"\\n            heading.style.font.name = \'黑体\'\\n            heading.style.font.size = Pt(font_size)\\n            heading.style.font.bold = True\\n            heading.style.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.LEFT\\n            heading.style.paragraph_format.space_before = Pt(space_before)\\n            heading.style.paragraph_format.space_after = Pt(space_after)\\n            # Set Chinese font to ensure proper display\\n            heading.style._element.rPr.rFonts.set(qn(\'w:eastAsia\'), \'黑体\')\\n        \\n        if level <= 3:\\n            # Level 1-3 headings use Word built-in heading styles\\n            heading = doc.add_heading(numbered_text, level=level)\\n            config = level_configs[level]\\n            apply_heading_style(heading, config[\'font_size\'], config[\'space_before\'], config[\'space_after\'])\\n            return heading\\n        else:\\n            # Level 4+ headings also use add_heading but with level=3 style (Word supports up to level 3)\\n            heading = doc.add_heading(numbered_text, level=3)\\n            config = level_configs[\'default\']\\n            apply_heading_style(heading, config[\'font_size\'], config[\'space_before\'], config[\'space_after\'])\\n            return heading\\n    \\n    # Internal function: process task content\\n    def process_task_content(task_content):\\n        \\n        # Helper function to add formatted title with different levels\\n        def add_formatted_title(title_text, level=1):\\n            \\"\\"\\"Add a formatted title paragraph with bold styling based on level\\"\\"\\"\\n            p = doc.add_paragraph()\\n            run = p.add_run(title_text)\\n            \\n            # Set font size and spacing based on title level\\n            if level == 1:\\n                run.font.size = Pt(13)\\n            elif level == 2:\\n                run.font.size = Pt(12)\\n            else:\\n                # Level 3 and deeper\\n                run.font.size = Pt(11)\\n            \\n            return p\\n        \\n        # Helper function to detect title level from numbered titles\\n        def get_numbered_title_level(line):\\n            \\"\\"\\"Detect the level of numbered titles like 1., 1.1, 1.1.1, etc.\\"\\"\\"\\n            # Handle Chinese numerals first\\n            if line.startswith(CHINESE_NUMBER_PREFIXES):\\n                return 1\\n            \\n            # Handle Arabic numerals\\n            if line and line[0].isdigit():\\n                # Count the number of dots to determine level\\n                # 1. = level 1, 1.1 = level 2, 1.1.1 = level 3, etc.\\n                parts = line.split()\\n                if parts:\\n                    number_part = parts[0]\\n                    dot_count = number_part.count(\'.\')\\n                    return dot_count + 1\\n            \\n            return 1\\n        \\n        lines = task_content.strip().split(\'\\\\n\')\\n        i = 0\\n        \\n        while i < len(lines):\\n            line = lines[i].strip()\\n            if not line:\\n                i += 1\\n                continue\\n            \\n            # Check for markdown headers (# ## ### etc.)\\n            if line.startswith(\'#\'):\\n                hash_count = 0\\n                for char in line:\\n                    if char == \'#\':\\n                        hash_count += 1\\n                    else:\\n                        break\\n                # Extract title text after the # symbols\\n                title_text = line[hash_count:].strip()\\n                if title_text:\\n                    # Use unified title formatting function\\n                    add_formatted_title(title_text, level=hash_count)\\n                i += 1\\n                continue\\n            \\n            # Check for numbered section headers (1. 2. 1.1 etc.) \\n            elif line and (line[0].isdigit() or line.startswith(CHINESE_NUMBER_PREFIXES)):\\n                # Detect title level and use unified formatting\\n                title_level = get_numbered_title_level(line)\\n                add_formatted_title(line, level=title_level)\\n                i += 1\\n                continue\\n            \\n            # Handle code blocks\\n            elif line.startswith(\'```\'):\\n                # Find the end of code block\\n                code_lines = [line]\\n                i += 1\\n                while i < len(lines):\\n                    code_lines.append(lines[i])\\n                    if lines[i].strip().startswith(\'```\'):\\n                        break\\n                    i += 1\\n                \\n                # Add code block as a paragraph with monospace font\\n                code_text = \'\\\\n\'.join(code_lines)\\n                p = doc.add_paragraph(code_text)\\n                # Set monospace font for code\\n                for run in p.runs:\\n                    run.font.name = \'Courier New\'\\n                    run.font.size = Pt(9)\\n                p.paragraph_format.space_after = Pt(6)\\n                i += 1\\n                continue\\n            \\n            # Handle bullet points and lists\\n            elif line.startswith((\'- \', \'• \', \'* \', \'+ \')):\\n                # Remove the bullet symbol and add as list item\\n                list_text = line[2:].strip()\\n                p = doc.add_paragraph(list_text, style=\'List Bullet\')\\n                p.paragraph_format.left_indent = Pt(18)\\n                i += 1\\n                continue\\n            \\n            # Handle numbered lists\\n            elif line.lstrip().startswith((\'(\', \'a)\', \'b)\', \'c)\', \'d)\', \'e)\', \'f)\', \'g)\', \'h)\', \'i)\', \'j)\', \'k)\', \'l)\', \'m)\', \'n)\', \'o)\', \'p)\', \'q)\', \'r)\', \'s)\', \'t)\', \'u)\', \'v)\', \'w)\', \'x)\', \'y)\', \'z)\')):\\n                p = doc.add_paragraph(line, style=\'List Number\')\\n                p.paragraph_format.left_indent = Pt(18)\\n                i += 1\\n                continue\\n            \\n            # Handle bold text (**text** or __text__)\\n            elif \'**\' in line or \'__\' in line:\\n                # Create paragraph and handle bold formatting\\n                p = doc.add_paragraph()\\n                text = line\\n                \\n                # Handle **bold** formatting\\n                while \'**\' in text:\\n                    before, rest = text.split(\'**\', 1)\\n                    if before:\\n                        p.add_run(before)\\n                    if \'**\' in rest:\\n                        bold_text, after = rest.split(\'**\', 1)\\n                        run = p.add_run(bold_text)\\n                        run.bold = True\\n                        text = after\\n                    else:\\n                        p.add_run(\'**\' + rest)\\n                        break\\n                \\n                # Add any remaining text\\n                if text and \'**\' not in text:\\n                    p.add_run(text)\\n                \\n                p.paragraph_format.space_after = Pt(6)\\n                i += 1\\n                continue\\n            \\n            # Handle table-like content (simple approach)\\n            elif \'|\' in line and line.count(\'|\') >= 2:\\n                # Simple table handling - just format as monospace\\n                p = doc.add_paragraph(line)\\n                for run in p.runs:\\n                    run.font.name = \'Courier New\'\\n                    run.font.size = Pt(9)\\n                p.paragraph_format.space_after = Pt(3)\\n                i += 1\\n                continue\\n            \\n            # Regular paragraph\\n            else:\\n                # Check if this might be a continuation of a list or code block\\n                if line.startswith(\'   \') or line.startswith(\'\\\\t\'):\\n                    # Indented text - treat as continuation\\n                    p = doc.add_paragraph(line)\\n                    p.paragraph_format.left_indent = Pt(36)\\n                    p.paragraph_format.space_after = Pt(3)\\n                else:\\n                    # Regular paragraph\\n                    p = doc.add_paragraph(line)\\n                    p.paragraph_format.space_after = Pt(6)\\n                \\n                i += 1\\n    \\n    # Internal function: recursively process subcategories\\n    def process_subcategories(subcategories, level=1):\\n        for category in subcategories:\\n            # Add section heading\\n            if \'name\' in category:\\n                add_heading(category[\'name\'], level=level)\\n            \\n            # Process task content\\n            if \'task\' in category:\\n                process_task_content(category[\'task\'])\\n            \\n            # Recursively process subcategories\\n            if \'subcategories\' in category and category[\'subcategories\']:\\n                process_subcategories(category[\'subcategories\'], level=level+1)\\n        \\n    # Add document title\\n    if \'name\' in task_data:\\n        title = doc.add_paragraph(task_data[\'name\'], style=\'CustomTitle\')\\n    \\n    # Process main content\\n    if \'task\' in task_data:\\n        process_task_content(task_data[\'task\'])\\n    \\n    # Recursively process subcategories\\n    if \'subcategories\' in task_data:\\n        process_subcategories(task_data[\'subcategories\'], level=1)\\n    \\n    # Save document\\n    try:\\n        doc.save(file_path)\\n        return {\\n            \\"success\\": \\"True\\",\\n            \\"file_path\\": f\\"file://{file_path}\\"\\n        }\\n    except Exception as e:\\n        return {\\n            \\"success\\": \\"False\\",\\n            \\"file_path\\": \\"\\"\\n        }"}', 4, '{"name": "input_var", "type": "object", "properties": {"success": {"name": "success", "type": "string", "value": "", "required": false, "max_length": 0, "sort_order": 1, "display_name": "Operation success"}, "file_path": {"name": "file_path", "type": "file", "value": "", "required": false, "sort_order": 2, "display_name": "Word file path"}}, "sort_order": 0, "display_name": "Input Object Variable"}', 0, NULL);
INSERT INTO `custom_tools` (`team_id`, `user_id`, `app_id`, `config`, `input_variables`, `dependencies`, `code`, `output_type`, `output_variables`, `publish_status`, `published_time`) VALUES (1, 1, @new_id, NULL, '{"name": "input_var", "type": "object", "properties": {"task_data": {"name": "task_data", "type": "json", "value": "", "required": true, "sort_order": 1, "display_name": "Task Data"}}, "sort_order": 0, "display_name": "Input Object Variable"}', '{"python3": ["python-docx"]}', '{"python3":"from docx import Document\\nfrom docx.shared import Pt\\nfrom docx.enum.text import WD_ALIGN_PARAGRAPH\\nfrom docx.enum.style import WD_STYLE_TYPE\\nfrom docx.oxml.ns import qn\\nfrom typing import Dict, Any\\nimport os\\nimport uuid\\n\\ndef main(task_data: Dict[str, Any]) -> dict:\\n    \\"\\"\\"\\n    Convert JSON data to Word document, with different levels corresponding to different sections\\n    \\n    Args:\\n        task_data: Can be JSON string or Python dictionary\\n        \\n    Returns:\\n        dict: Dictionary containing operation result and file path\\n    \\"\\"\\"\\n\\n    # Generate a unique filename using UUID\\n    file_name = f\\"{uuid.uuid4()}.docx\\"\\n    file_path = f\\"/storage/{file_name}\\"\\n    \\n    # Ensure directory exists\\n    directory = os.path.dirname(file_path)\\n    if not os.path.exists(directory):\\n        os.makedirs(directory, exist_ok=True)\\n    \\n    # Create new Word document\\n    doc = Document()\\n    \\n    # Set Chinese font\\n    doc.styles[\'Normal\'].font.name = \'宋体\'\\n    doc.styles[\'Normal\']._element.rPr.rFonts.set(qn(\'w:eastAsia\'), \'宋体\')\\n    \\n    # Add document title style\\n    title_style = doc.styles.add_style(\'CustomTitle\', WD_STYLE_TYPE.PARAGRAPH)\\n    title_style.font.name = \'黑体\'\\n    title_style.font.size = Pt(18)\\n    title_style.font.bold = True\\n    title_style.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER\\n    title_style.paragraph_format.space_before = Pt(24)\\n    title_style.paragraph_format.space_after = Pt(18)\\n    # Set Chinese font\\n    title_style._element.rPr.rFonts.set(qn(\'w:eastAsia\'), \'黑体\')\\n    \\n    # Add level counters\\n    level_counters = {}\\n    \\n    # Chinese numbers configuration (unified)\\n    CHINESE_NUMBERS = [\\n        \'一\', \'二\', \'三\', \'四\', \'五\', \'六\', \'七\', \'八\', \'九\', \'十\',\\n        \'十一\', \'十二\', \'十三\', \'十四\', \'十五\', \'十六\', \'十七\', \'十八\', \'十九\', \'二十\',\\n        \'二十一\', \'二十二\', \'二十三\', \'二十四\', \'二十五\', \'二十六\', \'二十七\', \'二十八\', \'二十九\', \'三十\',\\n        \'三十一\', \'三十二\', \'三十三\', \'三十四\', \'三十五\', \'三十六\', \'三十七\', \'三十八\', \'三十九\', \'四十\',\\n        \'四十一\', \'四十二\', \'四十三\', \'四十四\', \'四十五\', \'四十六\', \'四十七\', \'四十八\', \'四十九\', \'五十\'\\n    ]\\n    \\n    # Generate Chinese number prefixes for pattern matching\\n    CHINESE_NUMBER_PREFIXES = tuple(num + \'、\' for num in CHINESE_NUMBERS)\\n    \\n    def reset_counters_from_level(level):\\n        \\"\\"\\"Reset counters from specified level and below\\"\\"\\"\\n        keys_to_remove = [k for k in level_counters.keys() if k >= level]\\n        for key in keys_to_remove:\\n            del level_counters[key]\\n    \\n    def get_level_number(level):\\n        \\"\\"\\"Get level number for specified level\\"\\"\\"\\n        # Reset deeper level counters\\n        reset_counters_from_level(level + 1)\\n        \\n        # Increment current level counter\\n        if level not in level_counters:\\n            level_counters[level] = 0\\n        level_counters[level] += 1\\n        \\n        if level == 1:\\n            # First level uses Chinese numbers\\n            if level_counters[level] <= len(CHINESE_NUMBERS):\\n                return CHINESE_NUMBERS[level_counters[level] - 1] + \'、\'\\n            else:\\n                return f\\"{level_counters[level]}、\\"\\n        elif level == 2:\\n            # Second level uses \\"1.1, 1.2\\" format, corresponding to first level number\\n            first_level_num = level_counters.get(1, 1)  # Get first level number\\n            return f\\"{first_level_num}.{level_counters[level]}、\\"\\n        else:\\n            # Third level and beyond use multi-level numbers\\n            if level == 3:\\n                first_level_num = level_counters.get(1, 1)\\n                return f\\"{first_level_num}.{level_counters[2]}.{level_counters[level]} \\"\\n            elif level == 4:\\n                first_level_num = level_counters.get(1, 1)\\n                return f\\"{first_level_num}.{level_counters[2]}.{level_counters[3]}.{level_counters[level]} \\"\\n            elif level == 5:\\n                first_level_num = level_counters.get(1, 1)\\n                return f\\"{first_level_num}.{level_counters[2]}.{level_counters[3]}.{level_counters[4]}.{level_counters[level]} \\"\\n            else:\\n                # Deeper levels continue expansion\\n                first_level_num = level_counters.get(1, 1)\\n                parts = [str(first_level_num)]\\n                for i in range(2, level + 1):\\n                    if i in level_counters:\\n                        parts.append(str(level_counters[i]))\\n                return \'.\'.join(parts) + \' \'\\n\\n    # Internal function: add heading with level numbering\\n    def add_heading(text, level=1):\\n        # Get level number\\n        level_number = get_level_number(level)\\n        numbered_text = level_number + text\\n        \\n        # Define style configuration for each level\\n        level_configs = {\\n            1: {\'font_size\': 16, \'space_before\': 18, \'space_after\': 12},\\n            2: {\'font_size\': 14, \'space_before\': 12, \'space_after\': 8},\\n            3: {\'font_size\': 13, \'space_before\': 10, \'space_after\': 6},\\n            # Default configuration for level 4 and below\\n            \'default\': {\'font_size\': 12, \'space_before\': 8, \'space_after\': 4}\\n        }\\n        \\n        def apply_heading_style(heading, font_size, space_before, space_after):\\n            \\"\\"\\"Common function to apply heading styles\\"\\"\\"\\n            heading.style.font.name = \'黑体\'\\n            heading.style.font.size = Pt(font_size)\\n            heading.style.font.bold = True\\n            heading.style.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.LEFT\\n            heading.style.paragraph_format.space_before = Pt(space_before)\\n            heading.style.paragraph_format.space_after = Pt(space_after)\\n            # Set Chinese font to ensure proper display\\n            heading.style._element.rPr.rFonts.set(qn(\'w:eastAsia\'), \'黑体\')\\n        \\n        if level <= 3:\\n            # Level 1-3 headings use Word built-in heading styles\\n            heading = doc.add_heading(numbered_text, level=level)\\n            config = level_configs[level]\\n            apply_heading_style(heading, config[\'font_size\'], config[\'space_before\'], config[\'space_after\'])\\n            return heading\\n        else:\\n            # Level 4+ headings also use add_heading but with level=3 style (Word supports up to level 3)\\n            heading = doc.add_heading(numbered_text, level=3)\\n            config = level_configs[\'default\']\\n            apply_heading_style(heading, config[\'font_size\'], config[\'space_before\'], config[\'space_after\'])\\n            return heading\\n    \\n    # Internal function: process task content\\n    def process_task_content(task_content):\\n        \\n        # Helper function to add formatted title with different levels\\n        def add_formatted_title(title_text, level=1):\\n            \\"\\"\\"Add a formatted title paragraph with bold styling based on level\\"\\"\\"\\n            p = doc.add_paragraph()\\n            run = p.add_run(title_text)\\n            \\n            # Set font size and spacing based on title level\\n            if level == 1:\\n                run.font.size = Pt(13)\\n            elif level == 2:\\n                run.font.size = Pt(12)\\n            else:\\n                # Level 3 and deeper\\n                run.font.size = Pt(11)\\n            \\n            return p\\n        \\n        # Helper function to detect title level from numbered titles\\n        def get_numbered_title_level(line):\\n            \\"\\"\\"Detect the level of numbered titles like 1., 1.1, 1.1.1, etc.\\"\\"\\"\\n            # Handle Chinese numerals first\\n            if line.startswith(CHINESE_NUMBER_PREFIXES):\\n                return 1\\n            \\n            # Handle Arabic numerals\\n            if line and line[0].isdigit():\\n                # Count the number of dots to determine level\\n                # 1. = level 1, 1.1 = level 2, 1.1.1 = level 3, etc.\\n                parts = line.split()\\n                if parts:\\n                    number_part = parts[0]\\n                    dot_count = number_part.count(\'.\')\\n                    return dot_count + 1\\n            \\n            return 1\\n        \\n        lines = task_content.strip().split(\'\\\\n\')\\n        i = 0\\n        \\n        while i < len(lines):\\n            line = lines[i].strip()\\n            if not line:\\n                i += 1\\n                continue\\n            \\n            # Check for markdown headers (# ## ### etc.)\\n            if line.startswith(\'#\'):\\n                hash_count = 0\\n                for char in line:\\n                    if char == \'#\':\\n                        hash_count += 1\\n                    else:\\n                        break\\n                # Extract title text after the # symbols\\n                title_text = line[hash_count:].strip()\\n                if title_text:\\n                    # Use unified title formatting function\\n                    add_formatted_title(title_text, level=hash_count)\\n                i += 1\\n                continue\\n            \\n            # Check for numbered section headers (1. 2. 1.1 etc.) \\n            elif line and (line[0].isdigit() or line.startswith(CHINESE_NUMBER_PREFIXES)):\\n                # Detect title level and use unified formatting\\n                title_level = get_numbered_title_level(line)\\n                add_formatted_title(line, level=title_level)\\n                i += 1\\n                continue\\n            \\n            # Handle code blocks\\n            elif line.startswith(\'```\'):\\n                # Find the end of code block\\n                code_lines = [line]\\n                i += 1\\n                while i < len(lines):\\n                    code_lines.append(lines[i])\\n                    if lines[i].strip().startswith(\'```\'):\\n                        break\\n                    i += 1\\n                \\n                # Add code block as a paragraph with monospace font\\n                code_text = \'\\\\n\'.join(code_lines)\\n                p = doc.add_paragraph(code_text)\\n                # Set monospace font for code\\n                for run in p.runs:\\n                    run.font.name = \'Courier New\'\\n                    run.font.size = Pt(9)\\n                p.paragraph_format.space_after = Pt(6)\\n                i += 1\\n                continue\\n            \\n            # Handle bullet points and lists\\n            elif line.startswith((\'- \', \'• \', \'* \', \'+ \')):\\n                # Remove the bullet symbol and add as list item\\n                list_text = line[2:].strip()\\n                p = doc.add_paragraph(list_text, style=\'List Bullet\')\\n                p.paragraph_format.left_indent = Pt(18)\\n                i += 1\\n                continue\\n            \\n            # Handle numbered lists\\n            elif line.lstrip().startswith((\'(\', \'a)\', \'b)\', \'c)\', \'d)\', \'e)\', \'f)\', \'g)\', \'h)\', \'i)\', \'j)\', \'k)\', \'l)\', \'m)\', \'n)\', \'o)\', \'p)\', \'q)\', \'r)\', \'s)\', \'t)\', \'u)\', \'v)\', \'w)\', \'x)\', \'y)\', \'z)\')):\\n                p = doc.add_paragraph(line, style=\'List Number\')\\n                p.paragraph_format.left_indent = Pt(18)\\n                i += 1\\n                continue\\n            \\n            # Handle bold text (**text** or __text__)\\n            elif \'**\' in line or \'__\' in line:\\n                # Create paragraph and handle bold formatting\\n                p = doc.add_paragraph()\\n                text = line\\n                \\n                # Handle **bold** formatting\\n                while \'**\' in text:\\n                    before, rest = text.split(\'**\', 1)\\n                    if before:\\n                        p.add_run(before)\\n                    if \'**\' in rest:\\n                        bold_text, after = rest.split(\'**\', 1)\\n                        run = p.add_run(bold_text)\\n                        run.bold = True\\n                        text = after\\n                    else:\\n                        p.add_run(\'**\' + rest)\\n                        break\\n                \\n                # Add any remaining text\\n                if text and \'**\' not in text:\\n                    p.add_run(text)\\n                \\n                p.paragraph_format.space_after = Pt(6)\\n                i += 1\\n                continue\\n            \\n            # Handle table-like content (simple approach)\\n            elif \'|\' in line and line.count(\'|\') >= 2:\\n                # Simple table handling - just format as monospace\\n                p = doc.add_paragraph(line)\\n                for run in p.runs:\\n                    run.font.name = \'Courier New\'\\n                    run.font.size = Pt(9)\\n                p.paragraph_format.space_after = Pt(3)\\n                i += 1\\n                continue\\n            \\n            # Regular paragraph\\n            else:\\n                # Check if this might be a continuation of a list or code block\\n                if line.startswith(\'   \') or line.startswith(\'\\\\t\'):\\n                    # Indented text - treat as continuation\\n                    p = doc.add_paragraph(line)\\n                    p.paragraph_format.left_indent = Pt(36)\\n                    p.paragraph_format.space_after = Pt(3)\\n                else:\\n                    # Regular paragraph\\n                    p = doc.add_paragraph(line)\\n                    p.paragraph_format.space_after = Pt(6)\\n                \\n                i += 1\\n    \\n    # Internal function: recursively process subcategories\\n    def process_subcategories(subcategories, level=1):\\n        for category in subcategories:\\n            # Add section heading\\n            if \'name\' in category:\\n                add_heading(category[\'name\'], level=level)\\n            \\n            # Process task content\\n            if \'task\' in category:\\n                process_task_content(category[\'task\'])\\n            \\n            # Recursively process subcategories\\n            if \'subcategories\' in category and category[\'subcategories\']:\\n                process_subcategories(category[\'subcategories\'], level=level+1)\\n        \\n    # Add document title\\n    if \'name\' in task_data:\\n        title = doc.add_paragraph(task_data[\'name\'], style=\'CustomTitle\')\\n    \\n    # Process main content\\n    if \'task\' in task_data:\\n        process_task_content(task_data[\'task\'])\\n    \\n    # Recursively process subcategories\\n    if \'subcategories\' in task_data:\\n        process_subcategories(task_data[\'subcategories\'], level=1)\\n    \\n    # Save document\\n    try:\\n        doc.save(file_path)\\n        return {\\n            \\"success\\": \\"True\\",\\n            \\"file_path\\": f\\"file://{file_path}\\"\\n        }\\n    except Exception as e:\\n        return {\\n            \\"success\\": \\"False\\",\\n            \\"file_path\\": \\"\\"\\n        }"}', 4, '{"name": "input_var", "type": "object", "properties": {"success": {"name": "success", "type": "string", "value": "", "required": false, "max_length": 0, "sort_order": 1, "display_name": "Operation success"}, "file_path": {"name": "file_path", "type": "file", "value": "", "required": false, "sort_order": 2, "display_name": "Word file path"}}, "sort_order": 0, "display_name": "Input Object Variable"}', 1, CURRENT_TIMESTAMP());


INSERT INTO `apps` (`team_id`, `user_id`, `name`, `description`, `avatar`, `icon`, `icon_background`, `mode`, `enable_api`, `api_token`, `is_public`, `publish_status`, `attrs_are_visible`) VALUES (1, 1, 'Write Data to Excel', 'Use pandas library to write data to Excel files. Supports writing DataFrame data to new Excel files or specific worksheets in existing Excel files, with options to include index and column names.', NULL, '1', '', 4, 0, NULL, 1, 1, 1);
SET @new_id = LAST_INSERT_ID();
INSERT INTO `custom_tools` (`team_id`, `user_id`, `app_id`, `config`, `input_variables`, `dependencies`, `code`, `output_type`, `output_variables`, `publish_status`, `published_time`) VALUES (1, 1, @new_id, NULL, '{"name": "output", "type": "object", "properties": {"data": {"name": "data", "type": "json", "value": "", "required": true, "sort_order": 1, "display_name": "JSON format data"}, "sheet_name": {"name": "sheet_name", "type": "string", "value": "", "required": false, "max_length": 0, "sort_order": 2, "display_name": "Worksheet name"}, "include_index": {"name": "include_index", "type": "string", "value": "", "required": false, "max_length": 0, "sort_order": 3, "display_name": "Include index"}, "include_header": {"name": "include_header", "type": "string", "value": "", "required": false, "max_length": 0, "sort_order": 4, "display_name": "Include column names"}}, "sort_order": 0, "display_name": "", "to_string_keys": ""}', '{"python3": ["pandas", "openpyxl"]}', '{"python3":"import pandas as pd\\nimport json\\nimport os\\nimport uuid\\nfrom typing import Union, List, Dict, Any\\n\\ndef main(data: Union[List[Dict], Dict[str, Any]], sheet_name: str = \'Sheet1\', include_index: str = \'false\', include_header: str = \'true\') -> dict:\\n    \\"\\"\\"\\n    Write Python data to Excel file\\n    \\n    Args:\\n        data: Python data, can be a list of dictionaries or nested dictionaries\\n        sheet_name: Worksheet name, defaults to Sheet1\\n        include_index: Whether to include index, \'true\' or \'false\', defaults to \'false\'\\n        include_header: Whether to include column names, \'true\' or \'false\', defaults to \'true\'\\n    \\n    Returns:\\n        dict: Dictionary containing operation result and file path\\n    \\"\\"\\"\\n    \\n    # Generate a unique filename using UUID\\n    file_name = f\\"{uuid.uuid4()}.xlsx\\"\\n    file_path = f\\"/storage/{file_name}\\"\\n    \\n    # Ensure directory exists\\n    directory = os.path.dirname(file_path)\\n    if not os.path.exists(directory):\\n        os.makedirs(directory, exist_ok=True)\\n    \\n    # Create DataFrame from Python data\\n    try:\\n        df = pd.DataFrame(data)\\n    except Exception as e:\\n        return {\\n            \\"success\\": False,\\n            \\"message\\": f\\"Data conversion error: {str(e)}\\",\\n            \\"file_path\\": \\"\\"\\n        }\\n        \\n    # Set default sheet_name if None is provided\\n    if sheet_name is None:\\n        sheet_name = \'Sheet1\'\\n    \\n    # Convert include_index and include_header to boolean values\\n    include_index_bool = include_index and include_index.lower() == \'true\'\\n    include_header_bool = not include_header or include_header.lower() == \'true\'\\n\\n    # Write data to Excel file with openpyxl engine (xlsx format only)\\n    try:\\n        # Create new file\\n        with pd.ExcelWriter(file_path, engine=\'openpyxl\') as writer:\\n            df.to_excel(\\n                writer, \\n                sheet_name=sheet_name, \\n                index=include_index_bool, \\n                header=include_header_bool\\n            )\\n        \\n        return {\\n            \\"success\\": \\"True\\",\\n            \\"file_path\\": f\\"file://{file_path}\\"\\n        }\\n    except Exception as e:\\n        return {\\n            \\"success\\": \\"False\\",\\n            \\"file_path\\": \\"\\"\\n        }"}', 4, '{"name": "output", "type": "object", "properties": {"success": {"name": "success", "type": "string", "value": "", "required": true, "max_length": 0, "sort_order": 1, "display_name": "Operation success"}, "file_path": {"name": "file_path", "type": "file", "value": "", "required": false, "sort_order": 2, "display_name": "Excel file path"}}, "sort_order": 0, "display_name": "", "to_string_keys": ""}', 0, NULL);
INSERT INTO `custom_tools` (`team_id`, `user_id`, `app_id`, `config`, `input_variables`, `dependencies`, `code`, `output_type`, `output_variables`, `publish_status`, `published_time`) VALUES (1, 1, @new_id, NULL, '{"name": "output", "type": "object", "properties": {"data": {"name": "data", "type": "json", "value": "", "required": true, "sort_order": 1, "display_name": "JSON format data"}, "sheet_name": {"name": "sheet_name", "type": "string", "value": "", "required": false, "max_length": 0, "sort_order": 2, "display_name": "Worksheet name"}, "include_index": {"name": "include_index", "type": "string", "value": "", "required": false, "max_length": 0, "sort_order": 3, "display_name": "Include index"}, "include_header": {"name": "include_header", "type": "string", "value": "", "required": false, "max_length": 0, "sort_order": 4, "display_name": "Include column names"}}, "sort_order": 0, "display_name": "", "to_string_keys": ""}', '{"python3": ["pandas", "openpyxl"]}', '{"python3":"import pandas as pd\\nimport json\\nimport os\\nimport uuid\\nfrom typing import Union, List, Dict, Any\\n\\ndef main(data: Union[List[Dict], Dict[str, Any]], sheet_name: str = \'Sheet1\', include_index: str = \'false\', include_header: str = \'true\') -> dict:\\n    \\"\\"\\"\\n    Write Python data to Excel file\\n    \\n    Args:\\n        data: Python data, can be a list of dictionaries or nested dictionaries\\n        sheet_name: Worksheet name, defaults to Sheet1\\n        include_index: Whether to include index, \'true\' or \'false\', defaults to \'false\'\\n        include_header: Whether to include column names, \'true\' or \'false\', defaults to \'true\'\\n    \\n    Returns:\\n        dict: Dictionary containing operation result and file path\\n    \\"\\"\\"\\n    \\n    # Generate a unique filename using UUID\\n    file_name = f\\"{uuid.uuid4()}.xlsx\\"\\n    file_path = f\\"/storage/{file_name}\\"\\n    \\n    # Ensure directory exists\\n    directory = os.path.dirname(file_path)\\n    if not os.path.exists(directory):\\n        os.makedirs(directory, exist_ok=True)\\n    \\n    # Create DataFrame from Python data\\n    try:\\n        df = pd.DataFrame(data)\\n    except Exception as e:\\n        return {\\n            \\"success\\": False,\\n            \\"message\\": f\\"Data conversion error: {str(e)}\\",\\n            \\"file_path\\": \\"\\"\\n        }\\n        \\n    # Set default sheet_name if None is provided\\n    if sheet_name is None:\\n        sheet_name = \'Sheet1\'\\n    \\n    # Convert include_index and include_header to boolean values\\n    include_index_bool = include_index and include_index.lower() == \'true\'\\n    include_header_bool = not include_header or include_header.lower() == \'true\'\\n\\n    # Write data to Excel file with openpyxl engine (xlsx format only)\\n    try:\\n        # Create new file\\n        with pd.ExcelWriter(file_path, engine=\'openpyxl\') as writer:\\n            df.to_excel(\\n                writer, \\n                sheet_name=sheet_name, \\n                index=include_index_bool, \\n                header=include_header_bool\\n            )\\n        \\n        return {\\n            \\"success\\": \\"True\\",\\n            \\"file_path\\": f\\"file://{file_path}\\"\\n        }\\n    except Exception as e:\\n        return {\\n            \\"success\\": \\"False\\",\\n            \\"file_path\\": \\"\\"\\n        }"}', 4, '{"name": "output", "type": "object", "properties": {"success": {"name": "success", "type": "string", "value": "", "required": true, "max_length": 0, "sort_order": 1, "display_name": "Operation success"}, "file_path": {"name": "file_path", "type": "file", "value": "", "required": false, "sort_order": 2, "display_name": "Excel file path"}}, "sort_order": 0, "display_name": "", "to_string_keys": ""}', 1, CURRENT_TIMESTAMP());

COMMIT;
