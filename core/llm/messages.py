import sys
from pathlib import Path
sys.path.append(str(Path(__file__).absolute().parent.parent))

from base64 import b64encode
from typing import Any, Dict, List, Tuple, Union

from langchain_core.messages import HumanMessage

from .prompt import Prompt
from core.workflow.variables import create_variable_from_dict, Variable


project_root = Path(__file__).absolute().parent.parent.parent

HISTORY_MESSAGES_MAX_ROUNDS = 5 # The maximum number of rounds of messages to store in the history.

class Messages:
    """
    A Messages object is used to store the messages generated by the language model.
    """
    
    def __init__(self):
        """
        Initializes a Messages object with an optional list of messages.
        """
        self.messages: List[Tuple[str, Variable]] = []
        
    def _get_human_message_from_file_variable(self, file: Variable) -> HumanMessage:
        """
        Gets a HumanMessage object from a file variable.
        """
        file_path = project_root.joinpath(file.value)
        suffix_to_mime_subtype = {
            '.png': 'png',
            '.jpg': 'jpeg',
            '.jpeg': 'jpeg',
            '.webp': 'webp',
            '.gif': 'gif',
        }
        if file_path.suffix not in suffix_to_mime_subtype:
            raise ValueError(f"Unsupported file type: {file_path.suffix}")
        mime_subtype = suffix_to_mime_subtype[file_path.suffix]
        image_data = b64encode(file_path.read_bytes()).decode("utf-8")
        return HumanMessage(
            content=[
                {
                    "type": "image_url",
                    "image_url": {"url": f"data:image/{mime_subtype};base64,{image_data}"},
                }
            ],
        )
    
    def add_prompt(self, prompt: Prompt) -> None:
        """
        Adds a prompt to the list of messages.
        
        :param prompt: Prompt, the prompt to add.
        """
        if prompt.system:
            self.messages.append(("system", Variable(name="system", type="string", value=str(prompt.system.value))))
        if prompt.user:
            self.messages.append(("human", Variable(name="user", type="string", value=str(prompt.user.value))))
            
    def add_human_message(self, human_message: Variable) -> None:
        """
        Adds a human message to the list of messages.

        :param message: Variable, the human message to add.
        """
        self.messages.append(("human", Variable(name="user", type="string", value=str(human_message.value))))
            
    def add_ai_message(self, ai_message: Variable) -> None:
        """
        Adds an AI message to the list of messages.
        
        :param message: Variable, the AI message to add.
        """
        self.messages.append(("ai", Variable(name="assistant", type="string", value=str(ai_message.value))))
        
    def replace_variables(self, variables: Dict[str, Any] = {}) -> None:
        """
        Replaces variables in the messages with the provided values.
        
        :param variables: Dict[str, str], a dictionary where the key is the variable name and the value is the variable value.
        """
        if not variables:
            return
        for role, message in self.messages:
            if role != "ai":
                for var_name, var_value in variables.items():
                    if message.type == "string":
                        message.value = message.value.replace(
                            f'{{{var_name}}}',
                            str(var_value).replace('{', '{{').replace('}', '}}')
                        )
    
    def to_langchain_format(self) -> List[Union[Tuple[str, str], HumanMessage]]:
        """
        Converts the Messages object to a list of tuples in the LangChain format, respecting the maximum rounds limit.
        
        :return: list, a list of tuples in the LangChain format.
        """
        rounds = 0
        result = []
        for role, message in reversed(self.messages):
            if role == "ai":
                rounds += 1
                if rounds > HISTORY_MESSAGES_MAX_ROUNDS:
                    return result
            if role == "human" and message.type == "file":
                result.insert(0, self._get_human_message_from_file_variable(message))
            else:
                result.insert(0, (role, message.value))
        return result
    
    def serialize(self) -> List[Dict[str, Dict[str, str]]]:
        """
        Serializes the Messages object to a list of dictionaries.
        
        :return: list, a list of dictionaries.
        """
        result = []
        for role, message in self.messages:
            result.append((role, message.to_dict()))
        return result

    def reorganize_messages(self) -> None:
        """
        Reorganizes the messages by:
        1. Keeping only the last system message
        2. Moving that system message to the beginning
        3. Preserving the order of other messages
        """
        # Find the last system message
        last_system_message = None
        non_system_messages = []
        
        for role, message in self.messages:
            if role == "system":
                last_system_message = (role, message)
            else:
                non_system_messages.append((role, message))
        
        # Reconstruct the messages list
        self.messages = []
        if last_system_message:
            self.messages.append(last_system_message)
        self.messages.extend(non_system_messages)

def create_messages_from_serialized_format(serialized_data: List[Tuple[str, Dict[str, str]]]) -> Messages:
    """
    Converts a list of dictionaries to a Messages object.
    
    :param serialized_data: List[Dict[str, Dict[str, str]]], a list of dictionaries.
    :return: Messages, a Messages object containing the converted data.
    """
    messages = Messages()
    for role, message in serialized_data:
        messages.messages.append((role, create_variable_from_dict(message)))
    return messages
