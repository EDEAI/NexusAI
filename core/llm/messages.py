import sys
from pathlib import Path
sys.path.append(str(Path(__file__).absolute().parent.parent))

from base64 import b64encode
from copy import deepcopy
from typing import Any, Dict, List, Tuple, Union, Optional

from langchain_core.messages import HumanMessage, SystemMessage

from .prompt import Prompt
from core.workflow.variables import create_variable_from_dict, Variable


project_root = Path(__file__).absolute().parent.parent.parent

HISTORY_MESSAGES_MAX_ROUNDS = 5 # The maximum number of rounds of messages to store in the history.

class Messages:
    """
    A Messages object is used to store the messages generated by the language model.
    """
    
    def __init__(self):
        """
        Initializes a Messages object with an optional list of messages.
        """
        self.messages: List[Tuple[str, Variable]] = []
        
    def _get_human_message_from_file_variable(self, file: Variable) -> Union[HumanMessage, Tuple[str, str]]:
        """
        Gets a HumanMessage object from a file variable.
        """
        from core.database.models import UploadFiles
        
        if var_value := file.value:
            if isinstance(var_value, int):
                # Upload file ID
                file_data = UploadFiles().get_file_by_id(var_value)
                file_path = project_root.joinpath(file_data['path'])
            elif isinstance(var_value, str):
                if var_value[0] == '/':
                    var_value = var_value[1:]
                file_path = project_root.joinpath('storage').joinpath(var_value)
            else:
                # This should never happen
                raise Exception('Unsupported value type!')
            suffix_to_mime_subtype = {
                '.png': 'png',
                '.jpg': 'jpeg',
                '.jpeg': 'jpeg',
                '.webp': 'webp',
                '.gif': 'gif',
            }
            if file_path.suffix not in suffix_to_mime_subtype:
                raise ValueError(f"Unsupported file type: {file_path.suffix}")
            mime_subtype = suffix_to_mime_subtype[file_path.suffix]
            image_data = b64encode(file_path.read_bytes()).decode("utf-8")
            return HumanMessage(
                content=[
                    {
                        "type": "image_url",
                        "image_url": {"url": f"data:image/{mime_subtype};base64,{image_data}"},
                    }
                ],
            )
        return ("human", "")

    def add_system_message(self, system_message: Variable) -> None:
        """
        Adds a system message to the list of messages.

        :param message: Variable, the system message to add.
        """
        self.messages.append(("system", Variable(name="system", type="string", value=str(system_message.value))))
    
    def add_prompt(self, prompt: Prompt) -> None:
        """
        Adds a prompt to the list of messages.
        
        :param prompt: Prompt, the prompt to add.
        """
        if prompt.system:
            self.messages.append(("system", Variable(name="system", type="string", value=str(prompt.system.value))))
        if prompt.user:
            self.messages.append(("human", Variable(name="user", type="string", value=str(prompt.user.value))))
            
    def add_human_message(self, human_message: Variable, type: str = "string") -> None:
        """
        Adds a human message to the list of messages.

        :param message: Variable, the human message to add.
        """
        if type == "file":
            variable = deepcopy(human_message)
        else:
            variable = Variable(name="user", type=type, value=str(human_message.value))
        self.messages.append(("human", variable))
            
    def add_ai_message(self, ai_message: Variable) -> None:
        """
        Adds an AI message to the list of messages.
        
        :param message: Variable, the AI message to add.
        """
        self.messages.append(("ai", Variable(name="assistant", type="string", value=str(ai_message.value))))
        
    def replace_variables(self, variables: Dict[str, Any] = {}) -> None:
        """
        Replaces variables in the messages with the provided values.
        
        :param variables: Dict[str, str], a dictionary where the key is the variable name and the value is the variable value.
        """
        if not variables:
            return
        for role, message in self.messages:
            if role != "ai":
                for var_name, var_value in variables.items():
                    if message.type == "string":
                        message.value = message.value.replace(
                            f'{{{var_name}}}',
                            str(var_value).replace('{', '{{').replace('}', '}}')
                        )
    
    def to_langchain_format(
        self,
        model_name: str,
        supplier_name: str,
        restrict_max_rounds: bool = True,
        input_variables: Optional[Dict[str, Any]] = None
    ) -> List[Union[Tuple[str, str], HumanMessage]]:
        """
        Converts the Messages object to a list of tuples in the LangChain format, respecting the maximum rounds limit.
        
        :return: list, a list of tuples in the LangChain format.
        """
        rounds = 0
        result = []
        for role, message in reversed(self.messages):
            if role == "ai":
                rounds += 1
                if restrict_max_rounds and rounds > HISTORY_MESSAGES_MAX_ROUNDS:
                    return result
            if role == "human" and message.type == "file":
                result.insert(0, self._get_human_message_from_file_variable(message))
            elif role == "system" and (supplier_name == "OpenAI" and model_name in ["o1-preview", "o1-mini"]):
                # "o1-preview" and "o1-mini" does not support "developer" nor "system" messages.
                for i, (role, result_message) in enumerate(result):
                    if role == "human":
                        # Prepend the system message to the human message.
                        if input_variables:
                            result[i] = ("human", f"{message.value.format(**input_variables)}\n{result_message}")
                        else:
                            result[i] = ("human", f"{message.value}\n{result_message}")
                        break
            else:
                if input_variables:
                    result.insert(0, (role, message.value.format(**input_variables)))
                else:
                    result.insert(0, (role, message.value))
        return result
    
    def serialize(self) -> List[Dict[str, Dict[str, str]]]:
        """
        Serializes the Messages object to a list of dictionaries.
        
        :return: list, a list of dictionaries.
        """
        result = []
        for role, message in self.messages:
            result.append((role, message.to_dict()))
        return result

    def reorganize_messages(self) -> None:
        """
        Reorganizes the messages by:
        1. Keeping only the last system message
        2. Moving that system message to the beginning
        3. Preserving the order of other messages
        """
        # Find the last system message
        last_system_message = None
        non_system_messages = []
        
        for role, message in self.messages:
            if role == "system":
                last_system_message = (role, message)
            else:
                non_system_messages.append((role, message))
        
        # Reconstruct the messages list
        self.messages = []
        if last_system_message:
            self.messages.append(last_system_message)
        self.messages.extend(non_system_messages)

def create_messages_from_serialized_format(serialized_data: List[Tuple[str, Dict[str, str]]]) -> Messages:
    """
    Converts a list of dictionaries to a Messages object.
    
    :param serialized_data: List[Dict[str, Dict[str, str]]], a list of dictionaries.
    :return: Messages, a Messages object containing the converted data.
    """
    messages = Messages()
    for role, message in serialized_data:
        messages.messages.append((role, create_variable_from_dict(message)))
    return messages
