import sys
from pathlib import Path
sys.path.append(str(Path(__file__).absolute().parent.parent))

from base64 import b64encode
from copy import deepcopy
from typing import Any, Dict, List, Tuple, Union, Optional

from langchain_core.messages import HumanMessage

from .prompt import Prompt
from core.workflow.variables import create_variable_from_dict, Variable, ArrayVariable


project_root = Path(__file__).absolute().parent.parent.parent

HISTORY_MESSAGES_MAX_ROUNDS = 5 # The maximum number of rounds of messages to store in the history.

class Messages:
    """
    A Messages object is used to store the messages generated by the language model.
    """
    
    def __init__(self):
        """
        Initializes a Messages object with an optional list of messages.
        """
        self.messages: List[Tuple[str, Union[Variable, ArrayVariable]]] = []
        
    def convert_file_to_message_content(self, file: Variable) -> Dict:
        """
        Converts a file variable to a message content dictionary.
        
        :param file: Variable, the file variable containing image information.
        :return: Dict, a dictionary representing the image content for LangChain format.
        """
        from core.database.models import UploadFiles
        
        if var_value := file.value:
            if isinstance(var_value, int):
                # Upload file ID
                file_data = UploadFiles().get_file_by_id(var_value)
                file_path = project_root.joinpath(file_data['path'])
            elif isinstance(var_value, str):
                if var_value[0] == '/':
                    var_value = var_value[1:]
                file_path = project_root.joinpath('storage').joinpath(var_value)
            else:
                # This should never happen
                raise Exception('Unsupported value type!')
            suffix_to_mime_subtype = {
                '.png': 'png',
                '.jpg': 'jpeg',
                '.jpeg': 'jpeg',
                '.webp': 'webp',
                '.gif': 'gif',
            }
            if file_path.suffix not in suffix_to_mime_subtype:
                raise ValueError(f"Unsupported file type: {file_path.suffix}")
            mime_subtype = suffix_to_mime_subtype[file_path.suffix]
            image_data = b64encode(file_path.read_bytes()).decode("utf-8")
            return {
                "type": "image_url",
                "image_url": {"url": f"data:image/{mime_subtype};base64,{image_data}"},
            }
        raise ValueError("File variable has no value")

    def add_system_message(self, system_message: Variable) -> None:
        """
        Adds a system message to the list of messages.

        :param message: Variable, the system message to add.
        """
        self.messages.append(("system", Variable(name="system", type="string", value=str(system_message.value))))
    
    def add_prompt(self, prompt: Prompt) -> None:
        """
        Adds a prompt to the list of messages.
        
        :param prompt: Prompt, the prompt to add.
        """
        if prompt.system:
            self.messages.append(("system", Variable(name="system", type="string", value=str(prompt.system.value))))
        if prompt.user:
            self.messages.append(("human", Variable(name="user", type="string", value=str(prompt.user.value))))
            
    def add_human_message(self, human_message: Union[Variable, ArrayVariable]) -> None:
        """
        Adds a human message to the list of messages.

        :param human_message: Union[Variable, ArrayVariable], the human message to add.
        """
        if isinstance(human_message, ArrayVariable):
            variable = deepcopy(human_message)
            variable.name = "user"
        else:
            variable = Variable(name="user", type="string", value=str(human_message.value))
        
        self.messages.append(("human", variable))
            
    def add_ai_message(self, ai_message: Variable) -> None:
        """
        Adds an AI message to the list of messages.
        
        :param message: Variable, the AI message to add.
        """
        self.messages.append(("ai", Variable(name="assistant", type="string", value=str(ai_message.value))))
        
    def replace_variables(self, variables: Dict[str, Any] = {}) -> None:
        """
        Replaces variables in the messages with the provided values.
        
        :param variables: Dict[str, str], a dictionary where the key is the variable name and the value is the variable value.
        """
        if not variables:
            return
        for role, message in self.messages:
            if role != "ai":
                if isinstance(message, Variable) and message.type == "string":
                    for var_name, var_value in variables.items():
                        message.value = message.value.replace(
                            f'{{{var_name}}}',
                            str(var_value).replace('{', '{{').replace('}', '}}')
                        )
                elif isinstance(message, ArrayVariable):
                    for var in message.values:
                        if var.type == "string":
                            for var_name, var_value in variables.items():
                                var.value = var.value.replace(
                                    f'{{{var_name}}}',
                                    str(var_value).replace('{', '{{').replace('}', '}}')
                                )
    
    def to_langchain_format(
        self,
        model_name: str,
        supplier_name: str,
        restrict_max_rounds: bool = True,
        input_variables: Optional[Dict[str, Any]] = None
    ) -> List[Union[Tuple[str, str], HumanMessage]]:
        """
        Converts the Messages object to a list of tuples in the LangChain format, respecting the maximum rounds limit.
        
        :return: list, a list of tuples or message objects in the LangChain format.
        """
        rounds = 0
        result = []
        for role, message in reversed(self.messages):
            if role == "ai":
                rounds += 1
                if restrict_max_rounds and rounds > HISTORY_MESSAGES_MAX_ROUNDS:
                    return result
            
            # Handle ArrayVariable for human messages
            if role == "human" and isinstance(message, ArrayVariable):
                content = []
                text_content = ""
                
                # Process each variable in the array
                for var in message.values:
                    if var.type == "string":
                        if input_variables:
                            text_content += var.value.format(**input_variables) + "\n"
                        else:
                            text_content += var.value + "\n"
                    elif var.type == "file" and getattr(var, "sub_type", None) == "image":
                        content.append(self.convert_file_to_message_content(var))
                
                # Add text content if present
                if text_content.strip():
                    content.insert(0, {"type": "text", "text": text_content.strip()})
                
                # Create a HumanMessage object with multimodal content
                if content:
                    result.insert(0, HumanMessage(content=content))
            elif role == "system" and (supplier_name == "OpenAI" and model_name in ["o1-preview", "o1-mini"]):
                # "o1-preview" and "o1-mini" does not support "developer" nor "system" messages.
                for i, item in enumerate(result):
                    if isinstance(item, tuple) and item[0] == "human":
                        # Prepend the system message to the human message.
                        if input_variables:
                            result[i] = ("human", f"{message.value.format(**input_variables)}\n{item[1]}")
                        else:
                            result[i] = ("human", f"{message.value}\n{item[1]}")
                        break
                    elif isinstance(item, HumanMessage):
                        # For HumanMessage objects with content list
                        content_list = item.content
                        # Find text content if exists
                        for j, content_item in enumerate(content_list):
                            if content_item.get("type") == "text":
                                if input_variables:
                                    sys_message = message.value.format(**input_variables)
                                else:
                                    sys_message = message.value
                                content_list[j]["text"] = f"{sys_message}\n{content_item['text']}"
                                break
                        else:
                            # If no text content found, add it at the beginning
                            if input_variables:
                                sys_message = message.value.format(**input_variables)
                            else:
                                sys_message = message.value
                            content_list.insert(0, {"type": "text", "text": sys_message})
                        break
            else:
                if input_variables and isinstance(message, Variable) and message.type == "string":
                    result.insert(0, (role, message.value.format(**input_variables)))
                else:
                    result.insert(0, (role, message.value))
        return result
    
    def serialize(self) -> List[Tuple[str, Dict[str, Any]]]:
        """
        Serializes the Messages object to a list of dictionaries.
        
        :return: list, a list of tuples with role and message dictionary.
        """
        result = []
        for role, message in self.messages:
            result.append((role, message.to_dict()))
        return result

    def reorganize_messages(self) -> None:
        """
        Reorganizes the messages by:
        1. Keeping only the last system message
        2. Moving that system message to the beginning
        3. Preserving the order of other messages
        """
        # Find the last system message
        last_system_message = None
        non_system_messages = []
        
        for role, message in self.messages:
            if role == "system":
                last_system_message = (role, message)
            else:
                non_system_messages.append((role, message))
        
        # Reconstruct the messages list
        self.messages = []
        if last_system_message:
            self.messages.append(last_system_message)
        self.messages.extend(non_system_messages)

def create_messages_from_serialized_format(serialized_data: List[Tuple[str, Dict[str, Any]]]) -> Messages:
    """
    Converts a list of dictionaries to a Messages object.
    
    :param serialized_data: List[Tuple[str, Dict[str, Any]]], a list of tuples with role and message dictionary.
    :return: Messages, a Messages object containing the converted data.
    """
    messages = Messages()
    for role, message in serialized_data:
        messages.messages.append((role, create_variable_from_dict(message)))
    return messages
